# Head first Object Oriented Analysis and Design Book
   This book is talking about a good software, how it's Analysis and Design looks like with examples.

# Table of Contents
* [Chapter One](#chapter-one)
* [Chapter Two](#chapter-two)
* [Chapter Three](#chapter-three)
* [Chapter Four](#chapter-four)

## Chapter One

  1. Write software that do what the client need it do.
  2. Apply some OOP princibles to be well designed and easy to maintain.
  3. Make it reusable and maintainable.

  ### Bullet Points

  * It takes very little for something to go wrong with an application that is fragile.

  * You can use OO principles like encapsulation and delegation to build applications that are flexible.

  * Encapsulation is breaking your application into logical parts that have a clear boundary that allows an object to hide its data and methods from other objects.

  * Delegation is giving another object the responsibility of handling a particular task.

  * Always begin a project by figuring out what the customer wants.

  * Once you’ve got the basic functionality of an app in place, work on refining the design so it’s flexible.

  * With a functional and flexible design, you can employ design patterns to improve your design further, and make your app easier to reuse.

  * Find the parts of your application that change often, and try and separate them from the parts of your application that don’t change.

  * Building an application that works well but is poorly designed satisfies the customer but will leave you with pain, suffering, and lots of late nights fixing problems.

  * Object oriented analysis and design (OOA&D) provides a way to produce well-designed applications that satisfy both the customer and the programmer.


## Chapter Two
   1. Gathering information from customers and stackHolders
   2. Make Use case for your Application from client's requierments.
   3. Make sure that software work proberly as the client want it do.

  ### Bullet Points
   * Requirements are things your system must do to work correctly.

   * Your initial requirements usually come from your customer.

   * To make sure you have a good set of requirements, you should develop use cases for your system.

   * Use cases detail exactly what your system should do.

   * A use case has a single goal, but can have multiple paths to reach that goal.

   * A good use case has a starting and stopping condition, an external initiator, and clear value to the user.

   * A use case is simply a story about how your system works.

   * You will have at least one use case for each goal that your system must accomplish.

   * After your use cases are complete, you can refine and add to your requirements.

   * A requirements list that makes all your use cases possible is a good set of requirements.

   * Your system must work in the real world, not just when everything goes as you expect it to.

   * When things go wrong, your system must have alternate paths to reach the system’s goals.



## Chapter four
   1. Write use case
   2. Nouns in the use case are usually used as classes
   3. verbs in the use case are usually used as methods

   ### BULLET POINTS
* Analysis helps you ensure that your software works in the real world context, and not just in a perfect environment.

* Use cases are meant to be understood by you, your managers, your customers, and other programmers.

* You should write your use cases in whatever format makes them most usable to you and the other people who are looking at them.

* A good use case precisely lays out what a system does, but does not indicate how the system accomplishes that task.

* Each use case should focus on only one customer goal. If you have multiple goals, you will need to write multiple use cases.

* Class diagrams give you an easy way to show your system and its code constructs at a 10,000-foot view.

* The attributes in a class diagram usually map to the member variables of your classes.

* The operations in a class diagram usually represent the methods of your classes.

* Class diagrams leave lots of detail out, such as class constructors, some type information, and the purpose of operations on your classes.

* Textual analysis helps you translate a use case into code-level classes, attributes, and operations.

* The nouns of a use case are candidates for classes in your system, and the verbs are candidates for methods on your system’s classes.


## Chapter six

1. You can solve a big problem by breaking it into lots of functional pieces, and then working on each of those pieces individually.

2. 1. One way you can find out more about a system is to figure out what the system is like. In other words, are there some things that you do know about that the system functions or behaves like?  (commonality)

2. 2. Another great way to find out what a system should do is to figure out what it’s not like. This helps you determine what you don’t need to worry about in your system. (variability)

3. Use case is for both developers and customer

4. analysis Domain analysis is representing a system in language that the customer will understand.

5. The feature is the big picture of thing that sysytem does and consists of requirements.

### BULLET POINTS
* The best way to look at a big problem is to view it as a collection of smaller problems.

* Just like in small projects, start working on big projects by gathering features and requirements.

* Features are usually “big” things that a system does, but also can be used interchangeably with the term “requirements.”

* Commonality and variability give you points of comparison between a new system and things you already know about.

* Use cases are detail-oriented; use case diagrams are focused more on the big picture.

* Your use case diagram should account for all the features in your system.

* Domain analysis is representing a system in language that the customer will understand.

* An actor is anything that interacts with your system, but isn’t part of the system.
